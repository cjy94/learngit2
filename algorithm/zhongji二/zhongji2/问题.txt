1、给定一个长度大于3的数组arr， 返回该数组能不能分成4个部分，并且每个部分的累加和相等
哈希表存储每个索引位置的前缀累加和信息




2、一个数的因子仅仅包含2,3,5的数称为丑数。 数字1特别对待也看作是丑数，所以从1开始的10个丑数分别为1、2、3、4、5、6、8、9、10、12,
返回第n个丑数

3、给定一个无序数组arr，如果只能对一个子数组进行排序，但是想让数组整体都有序，求需要排序的最短数组长度

例如：arr=[1,5,3,4,2,6,7] 返回4， 因为只有[5,3,4,2] 需要排序

两次遍历，可以实现，时间复杂度O(N)
从左往右遍历： 当前数和左侧最大值的关系， cur >= max左 (√)； cur < max左 (×)    最后一个×号的位置
从右往左遍历： 当前数右左侧最小值的关系， cur <= min右 (√)； cur > min右 (×)    第一个×号的位置

4、最小不可组成和问题
给定一个正数数组arr，其中所有的值都为整数，以下是最小不可组成和的概念：
把arr每个子集内的所有元素加起来会出现很多值，其中最小的记为min， 最大的记为max，在区间[min, max]上，
如果有数不可以被arr某一个子集相加得到， 那么其中最小的那个数是arr的最小不可组成和

算法原型： 背包问题，从左到右的尝试模型


dp[i][j]: arr[0..i]未知的数自由组合，能否组合出j?
dp[i][j] =  dp[i-1][j] || dp[i-1][j-arr[i]]


进阶：如果正数数组中肯定有1这个数，能否更快的得到最小不可组成和
[1,1,1,1,1,1,4]  range=1
arr[cur], arr[cur] <= range, range+arr[cur]

5、



