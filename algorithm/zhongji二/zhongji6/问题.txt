1、范围上的尝试模型
添加最少字符使字符串整体都是回文字符串    str="ABA" 本身是回文，不需要添加字符，返回"ABA"; str="AB" 添加'A'或者'B', 形成回文

技巧： (1) 构建dp表； (2) 根据dp表，还原决策路径


dp[l][r]: 表示，str[l...r]范围上至少添加几个字符，可以形成回文字符串
情况由：
1.1 如果str[l]==str[r], 那么dp[l+1][r-1]的结果就是dp[l][r]的结果     dp[l+1][r-1];
1.2 先将str[l+1...r]处理成回文字符串，在str[l+1...r]的后面添加str[l]   dp[l+1][r]+1;
1.3 先将str[l...r-1]处理成回文字符串，在str[l...r-1]的前面添加str[r]   dp[l][r-1]+1;


2、 给定一个有序数组zrr, 和一个整数aim， 请不重复打印arr中所有累加和为aim的 二元组/三元组
规则：
2.1 arr[l]+arr[r] > aim, r--
2.2 arr[l]+arr[r] < aim, l++
2.3 arr[l]+arr[r]==aim,  比较arr[l]和arr[l-1]的值， (1) 相等，不记录，l++; (2) 不相等，记录， l++


3、给定一个整形矩阵nums，每个位置可以向左、右、上、下四个方向，找到其中最长的递增路径
例如：
nums=[
[9,9,4],
[6,6,8],
[2,1,1]
]
输出4， 最长的递增路径为：[1,2,6,9]

思路： 枚举每一个位置出发可形成的最长递增路径长度，从所有结果中取最大值

int ans = 0;
for (int i =0; i < arr.length; i++) {
    for (int j=0; j < arr[0].length; j++) {
       ans = Math.max(ans, process(nums, i, j));
    }
}

4、给定一个整型矩阵和一个整数k， 找到不大于k的最大子矩阵累加和
技巧： 数组压缩技巧
本质问题： 先找到累加和不大于k的，最大累加和子数组问题  （前缀和问题）


5、无向图节点类型， 给定一个出发点node，请克隆整张图
宽度优先遍历，可以使用队列+set(放置节点重复)实现




