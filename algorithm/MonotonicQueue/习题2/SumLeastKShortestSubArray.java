package com.chenjunyi.MonotonicQueue.习题2;

/**
  和至少为k的最短子数组
    给定一个数组arr，其中值有可能是正数、负数、0
    给定一个正数k， 返回累加和>=k的所有子数组中，最短子数组的长度


    046 构建前缀和信息，解决子数组的相关问题

   arr[0...n]  生成前缀和数组sun[0-0, 0-1, 0-2, 0-3, 0-4, 0-5, 0-6 ... 0-n]的前缀和数组

              0 1 2 3 4 5 6 7 8 9 10
 比如： arr= [1,1,1,6,8,2,9,1,5,4,1]   ， k = 10

    前缀和数组由单调队列维护，单调队列要求数据是从小到大的排序
    queue: [1, 2, 3, 9, 17]
    (1) 0-4的的前缀和是17, 0-4的前缀个已经满足了大于等于k的条件，可以向前查找1-4是否满足要求，2-4是否满足要求...
            17-1 = 16， 16也是满足大于等于10这个要求的，所以单调队列h指向的元素被使用过一次后可以出队列，因为最后要返回子数组长度的最小值，1-4既然满足要求， 就没必要再求1-5,1-6的子数组，长度都会大于1-4
            17-2 = 15， 15也是满足大于等于10这个要求的，所以1索引位置也可以出队列
            17-3 = 14， 14也是满足大于等于10这个要求的，所以2索引位置也可以出队列
            17-9 = 8，  8不再满足大于等于10这个要求，故以4结尾的最好答案是3-4 长度为2
    queue: [9, 17, 19]
    (2) 0-5的前缀个是19，19-9 = 10， 满足大于等于10的要求，索引3可以弹出队列
                        19-17 = 2， 不满足要求，所以5结尾情况的最好答案是4-5， 长度为2
    queue: [17, 19, 28]
        ... 索引6，索引7.. 都按照前面的步骤去计算

    再单调队列中依次准备好由小到大的组织，当来到arr数组的i位置，0-i的前缀和是X的时候，我们从单调队列的头部开始使用，能达标的，计算一个答案，将h弹出队列

    从头部淘汰可能性
   
    

 */
public class SumLeastKShortestSubArray {

    static int MAX = 10000;
    static int[] queue = new int[MAX];
    static int h = 0;
    static int t = 0;


    public static int leastK(int[] nums, int k) {
        // 构建前缀和数组
        int n = nums.length;
        int[] sum = new int[n+1];
        for (int i = 0; i <n; i++) {
            sum[i+1] = sum[i] + nums[i];
        }

        //遍历前缀和数组，每遍历一个数字，就和单调队列头部的数据进行计算，看是否满足要求
        int ans = Integer.MAX_VALUE;
        for (int i =0; i <= n;i++) {
            while (h < t && sum[i] + sum[queue[h]] >= k) {
                ans = Math.min(ans, (i-queue[h]));
                h--;
            }

            // 将新遍历到的元素加入到单调队列中
            // 队列从小到大，那么就要求，新加入的元素要大于队列t-1位置的元素
            while (h < t && sum[i] <= sum[queue[t-1]]) {
                t--;
            }

            queue[t++] = i;
        }
        return ans != Integer.MAX_VALUE ? ans : -1;

    }
}
