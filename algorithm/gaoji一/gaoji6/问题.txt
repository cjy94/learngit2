1、给定一个arr，长度为N且每个值都是正数， 代表N个人的体重， 再给定一个正数limit，代表一艘船的载重。
以下是坐船规则，1）每艘船最多只能做两人； 2）乘客的体重和不能超过limit，返回如何同时让这N个人过河最少需要几条船

利用双指针， 指针指向limit/2的位置，

L = limit/2
R = L+1

X V V X V X V V V X X X V V V V V V
1 1 1 2 2 3 3 4 4 5 5 5 6 6 7 8 9 9     limit=10
                      L R
arr[L]+arr[R] <= limit     R++     [L+1...R]
rr[L]+arr[R] > limit       L--;    [L...R-1]这部分的数据是无法处理的

船的个数是： (X+1)/2 + V/2 + 右侧超过limit/2需要单独一条船的人数



范围上的尝试模型




最长子序列问题 LongestPalindromeSubSequence
2、给定一个字符串str，求最长的回文子序列，
思路： 一个str和他的逆序串str` 两个求最长公共子序列，就代表着原始串的最长回文子序列
1b2a3c2g1 回文子序列   12321
str=1b2a3c2g1  str`= 1g2c3a2b1  求这两个字符串的最长的公共子序列就是str的最长回文子序列




尝试模型： 1、范围的尝试模型   str[i...j] 最长回文子序列   创建dp[i][j]  一个正方形的dp表, 表示str[i..j]范围上的最长公共子序列

范围的尝试模型，重点讨论以i开头以j结尾的情况，以及先填写主对角线和次对角线的值，一般主对角线的信息是通过str[i]一个字符决定的
次对角线str[i,j]两个字符决定的


str="112ab3cd2e1"  dp[0][N] 是要求的值，也就是str[0..N] 范围上形成的最长回文序列

再范围上尝试的模型，重点讨论开头和结尾
2.1 不以i开头， 不以j结尾   dp[i+1][j-1]
2.2 以i开头， 不以j结尾     dp[i][j-1]
2.3 不以i开头，以j结尾      dp[i+1][j]
2.4 以i开头， 以j结尾      str[i]==str[j]  dp[i+1][j-1]+2


3、给定一个字符串str, 如果可以在str的任意位置添加字符，请返回在添加字符最少的情况下，让str整体都是回文的一种结果
例如：str="ABA" str本身就是回文串，不需要添加字符， 返回"ABA"
     str="AB"  可以在'A'之前添加'B'， 使str整体都是回文串，故可以返回"BAB"，也可以在'B'之后添加'A', 使str整体都是回文串


尝试模型：
dp[i][j]: str[i..j]范围上至少添加几个字符，是的str[i..j]范围上形成回文字符串
情况有：
3.1 搞定str[i+1...j]形成回文， str[i]添加到字符串尾部，整体是回文 dp[i+1][j] +1
3.2 搞定str[i...j-1]形成回文，str[j]添加到字符串的头部，整体是回文 dp[i][j-1] +1
3.3 如果str[i]==str[j], 搞定str[(i+1)...(j-1)]整体是回文    dp[i+1][j-1]
以上3种情况取最小值

4、给定一个字符串，  返回把str全部切成回文子串的最小分割数

递归函数定义成： 从i出发， 往后所有的字符串最少能够切成的回文个数
例如： aabaakck
   a+f(1)        可以
   aa+f(2)       可以
   aab+f(3)      不行
   aaba+f(4)     不行
   aabaa+f(5)    可以
   aabaak+f(6)   不行
   aabaakc+f(7)  不行
   aabaakck+f(8) 不行


补充一个范围上的尝试模型，验证一个字符串是否是 回文字符串
boolean dp[i][j]: 表示str[i..j]位置上的字符串是否是回文字符串
情况有：
1、如果str[i]==str[j]    dp[i][j] = dp[i+1][j-1]
2、如果str[i]和str[j]字符不相等， dp[i][j] = false;


5、牛牛特别喜欢回文串， 他手中有一个字符串s， 牛牛在思考能否从字符串种移除部分（0个或者多个）字符使其变为回文， 并且牛牛认为空字符串不是回文串， 牛牛发现移除的方案可能有很多种，
希望你来计算下一共有多少种移除方案可以使s变为回文串。
例如：
XXY  4种，  {X}: 0位置    {X}: 1位置     {Y}       {XX}
ABA 5种     {A}: 0位置    {B}    {A}: 2位置       {AA}       {ABA}


范围内的尝试模型 dp[i][j] 表示str[i...j]范围上的回文字符串有多少种？
(1)  以i开头， 以j结尾             dp[i][j]
(2)  不以i开头，不以j结尾           dp[i+1][j-1]
(3)  不以i开头，以j结尾             dp[i+1][j]
(4)  以i开头，不以j结尾             dp[i][j-1]


重要：dp[i][j]表示str[i...j]所有可能的回文情况都算，有多少回文序列
可能情况分类： 按照必须开头，必须结尾分情况


0 1 2
A B A      dp[0][2]的解

(1) 以0开头， 以2结尾       {A(0)A(2)} {A(0)B(1)A(2)}
(2) 不以0开头，以2结尾       {A(2)}
(3) 不以0开头，不以2结尾     {B(1)}
(4) 以0开头， 不以2结尾      {A(0)}

5种情况全部包含， 全量且互斥

dp[0][1]: {A(0)} {B(1)}    (3)+(4)的解
dp[1][2]: {B(1)} {A(2)}    (2)+(3)的解

所以dp[i][j-1] + dp[i+1][j] 的解等于(3)+(4)+(2)+(3)-(3)  才是正确的解

dp[i][j-1] 一定不以j结尾 (3)+(4)
dp[i+1][j] 一定不以i开头 (2)+(3)

情况(1) str[i]==str[j]成立，才有效   dp[i+1][j-1]+1



