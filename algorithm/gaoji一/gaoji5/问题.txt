1、一个char类型的数组chs, 其中所有的字符都不相同，
例如： chs=['A','B','C'...'Z']， 则字符串与正数的对应关系如下：
A B C ... Z  AA AB AC ... AZ BA BB .. ZZ  AAA ... ZZZ   AAAA ....
1 2 3     26 27 28 29 ... 52 53 54 .. 702 703 ... 18278 18279 ...
请实现一个数字和字符串相互转换的函数
K 伪进制(满足每个位数上的数字是  1-3) ， 每一位都得有数，


使用二叉树的递归套路
2、给定一颗二叉树的头节点x, 可以从树中的任何一点出发，如果走的话只能向下，也可以选择随时停止，所形成的轨迹叫做一条路径，
路径上所有值的累加和叫做路径和，求这颗树上的最大路径和
可以使用二叉树的递归套路
有2种情况：
（1）x节点参与情况下的最大路径和
（1）x节点参与情况下的最大路径和
    (1.1) 最大的路径是X自己
    (1.2) 以左孩子开始点走出来的最大路径和     maxHeadLeftPath
    (1.3) 以右孩子开始点走出来的最大路径和     maxHeadRightPath
   
（2）x节点不参与情况下的最大路径和
    (2.1) x左子树的最大路径和  maxDistance
    (2.2) x右子树的最大路径和  maxDistance   两者取最大值即可




3、蛇长度问题, 从左侧任意位置出发，每次只能够到达当前位置的右上、右侧或者右下相邻的单元格。
每次到达一个单元格，自身的长度都会加上该单元格的数值，任何情况下，长度为负则游戏结束。
有一次超能力，可以在游戏开始的时候把地图中某一个节点的值变为其相反数，求蛇的最长长度是多少
1 -4 10
3 -2 -1
2 -1  0
0  5 -1

结果是： 3 -> -4(4) ->10

使用尝试方法，列举出蛇在每一个位置上的最长长度

4、给定一个字符串str, str表示一个公式，公式里可能有整数，加减乘除符号和左右括号，返回公式的计算结果
例如：
str="48*((70-65)-43)+8*1" 返回-1816
说明： 可以认为给定的字符串一定时正确的公式，不需要对str进行有效性检查
不用考虑计算过程中发生溢出的问题

解答： 该问题拆分成2个小问题，一个是如果表达式中没有括号，如果计算一个表达式的值（利用栈、队列等）； 如果表达式中存在括号，怎么计算表达式的值（递归拆解）。
递归策略 int[] f(str, i)  返回信息int[]一定是2个元素长度，第一个元素表示表达式的值，第二个元素表示计算的终止位置

(1) 第一个问题： 计算表达式的值（表达式中没有括号，只有运算符和数字）
   34-64*9+42*47       int num = 0;
   1、遇到数字字符： 数字累加到num上
   2、遇到运算符号：如果栈顶元素是'*','/'则将栈顶元素弹出两个计算后，将计算后的数值和运算符压入栈


(2) 第二个问题： 表达式中存在括号（递归处理解决）


5、给定两个字符串str1和str2， 求两个字符串的最长公共子串    [***** 空间压缩技巧 ******]

str1: a a b c a a c    str2: a a a b c c a b
      0 1 2 3 4 5 6          0 1 2 3 4 5 6 7

 dp[][] 以str1为行， str2为列:
 dp[row][col] 表示str1[0..i]， 必须以str1[i]结尾和str2[0..j]，必须以str2[j]结尾的情况下， 能组成的最长公共字串的长度是多少 ， 最长公共字串也必须以[i][j]结尾

正常的dp流程

     a a a b c c a b
     0 1 2 3 4 5 6 7
a 0 [1 1 1 0 0 0 1 0]    str[i] == str[j] 就是1， 否则就是0
a 1 [1 2 2 0 0 0 1 0]    普遍位置dp[i][j]
b 2 [0 0 0 3 0 0 0 2]          (1) str1[i] != str2[j]      dp[i][j] = 0
c 3 [0 0 0 0 4 1 0 0]          (2) str1[i] == str2[j]      dp[i][j] = dp[i-1][j-1] +1 ,  只依赖左上角的值
a 4 [1 1 1 0 0 0 2 0]
a 5 [1 2 2 0 0 0 1 0]
c 6 [0 0 0 0 1 1 0 0]

dp[][]表中的最大值就是答案

最优解： 使用的结构 ***后缀数组***

6、给定两个字符串str1和str2， 求两个字符串的最长公共子序列
dp[i][j] 表示： str1[0..i] 和str2[0..j] 组成的最长公共子序列长度， 不一定是以str1[i]和str2[j]结尾
dp[str1.length][str2.length]就是答案


公共字串必须以str1[i]和str2[j]结尾
公共子序列不需要以str1[i]和str2[j]结尾

可能性：
    （1）既不以i结尾也不以j结尾， 比如： str1=a12b3df   str2=zy12s3yt               dp[i][j] = dp[i-1][j-1]
    （2）可能以i结尾，但不以j结尾， 比如：str1=12345     str2=ab12cd345t            dp[i][j] = dp[i][j-1]
    （3）可能以j结尾，但不以i结尾， 比如：str1=ab12cd345t    str3=12345             dp[i][j] = dp[i-1][j]
    （4）既以i结尾又以j结尾， 在 str1[i] == str2[j] 成立的前提下，  比如：str1=ab12c3 str2=cd12e3     dp[i][j] = dp[i-1][j-1]+1

    以上4种可能性种的最大值就是答案









