bfprt?
完美洗牌问题
斜率优化

1、再一个无序数组中，找出最小的第k个数
快速排序，随机选择一个数，命中就返回，不命中就只走一侧继续找， 时间复杂度O(N)

方法一： 利用荷兰国旗问题，左右两侧只走一侧递归， 时间复杂度O(n)
 1.1  随机选择一个数
 1.2 partition,
 1.3 检查是否命中第k小，命中返回arr[m]
        未命中，左侧小于x区域， 继续递归；右侧大于x区域，继续递归， 左右两侧选择一侧
方法二： BFPRT
     2.1  随机选择一个数， 此处有差别， 不是随机选择一个数，
        差别： 
     2.2 partition,
     2.3 检查是否命中第k小，命中返回arr[m]
            未命中，左侧小于x区域， 继续递归；右侧大于x区域，继续递归， 左右两侧选择一侧


2、给定一个正数1，裂开的方法有一种  (1)
   给定一个整数2，裂开的方法有两种  (1和1)、(2)
   给定一个整数3，裂开的方法有三种  (1、1、1)、(1、2) (3)
   给定一个整数4，裂开的方法有五种  (1、1、1、1)、(1、1、2) (1、3) (2、2) (4)
   给定一个整数5，裂开的方法有七种  (1、1、1、1、1)、(1、1、1、2) (1、1、3) (1、2、2) (1、4) (2、3) (4)
   给定一个整数n，求裂开的方法数

   裂开的方案中必须是递增的才算一种裂开的方法，元素是非降序的

   暴力尝试的求解过程，比如2
                  3
            1/    \2   \3
            2      1    0
          1/ \2   1/   (3)
          1   0   (no)
         1/  (12)
         0
       (111)

其中每个位置有枚举行为比如f(2,6) 依赖 f(2,4) f(3,3) f(4,2) f(5,1) f(6,0)
                     f(3,6) 依赖 f(3,3) f(4,2) f(5,1) f(6,0)
                     故计算f(2,6) 只需要f(2,4)和f(3,6)即可 dp[pre][rest] = dp[pre][rest-pre]+dp[pre+1][rest]

从递归尝试 -> dp方法 -> 斜率优化的dp方式


3、给定一颗二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小
拓扑结构：不是子树， 只要能连起来的结构都算

二叉树的递归套路（*****）  较难





4、完美洗牌问题   原地调整， 时间O(N), 空间复杂度O(1)
a   b   c   d   e   f -> d   a   e   b   f   c
L1  L2  L3  R1  R2  R3   R1  L1  R2  L2  R3  L3

总结一个公式： i  ->  i`

左半区：i` = 2 * i;
右半区：i` = (i-n)*2 -1    4->1   5->3  6->5    右半区的第一个数去1位置， 第二个数去3位置， 第三个数去5位置


当N是一些比较特殊的偶数时， 会出现多个环， n = 2 8 26 ..... 3^k - 1
                                  出发点=1 3 9 ... 3^(k-1)


算法原型：N = 普遍偶数 ， 一段数组，将左侧划定的区域挪到右侧，右侧的区域挪到左侧
abcde甲乙   如何实现  甲乙abcde   额外空间复杂度O(1)
1、将abcde逆序    edcba
2、将甲乙逆序      乙甲
3、形成edcba乙甲  再整体逆序
4、整体逆序  甲乙abcde


