1、给定两个一维int数组A和B，
其中： A的长度为m, 元素从小大排好的有序数组，B长度是n，元素从小到大有序排好，希望从A和B数组种，找出最大的K个数字， (整体第k小，整体第k大 )
算法原型：
求长度是偶数的两个数组中的上中位数
求长度是奇数的两个数组中的上中位数

比如：
两个数组
数组中的元素值代表索引信息，不代表数组
A [1,2,3,4,5,6,7,8,9,10]      10个数
B [1`,2`,3`,4`,5`,6`,7`,8`,9`,10`,11`,12`,13`,14`,15`,16`,17`]  17个数
两个数组一共27个数，k取值的可能情况有3种
1） 1 <= k <= 10:  A[]中取出前k个元素，B[]中取出前k个元素，2k个元素中取中位数，刚好是第k个元素
2） 10 < k <= 17:   假如 k=15
        A[]中所有数都有可能是第15个数
        B[]中不可能的索引是：[1`,2`,3`,4`] 以及 [16`,17`]
        A中10个数， B中满足要求的11个数，两边数量不一致，所以手动比较B[5`]和A[10]的大小，如果B[5`]>=A[10], 那么第15小的数就是B[5`]
            否则B中不满要求的索引更新为：[1`,2`,3`,4`,5`] 以及 [16`,17`]
            A中10个数， B中10个数，2*10 20个数取中位数10， B中前面淘汰的5个数，10+5=15 ， 满足第15个数的要求
3） 17 < k <= 27: 大于段数组长度，小于总长度    k=23

        A[]中不可能的索引是：[1,2,3,4,5]
        B[]中不可能的索引是：[1`,2`,3`,4`,5`,6`,7`,8`,9`,10`,11`,12`]
        那么A中淘汰的数量是5， 剩余的个数：5， B 中淘汰的数量是12， 剩余的个数：5。 2*5 10个树中取中位数第5小的数，(5+12+5)=22, 不是第23个数
        所以手动比较A[6]和B[17`], 如果A[6]>= B[17`], 则A[6]是第23个数， 否则A中不满足的索引更新为[1,2,3,4,5,6]
              比较B[13`]和A[10],  如果B[13`]>= A[10], 则B[13`]是第23个数， 否则A中不满足的索引更新为[1`,2`,3`,4`,5`,6`,7`,8`,9`,10`,11`,12`,13`]
        这样，A中淘汰数量6,B中淘汰数量13, 2*4 8个数中取中位数4，6+13+4=23，满足第23个数的要求



取两个数组中位数的算法原型：

分别求出序列A 和B 的中位数，设为a 和b，求序列A 和B 的中位数过程如下：

1）若a=b，则a 或b 即为所求中位数，算法结束。

2）若a<b，则舍弃序列A 中较小的一半，同时舍弃序列B 中较大的一半,要求舍弃的长度相等；

3）若a>b，则舍弃序列A 中较大的一半，同时舍弃序列B 中较小的一半，要求舍弃的长度相等；





2、环形链表中，删除节点，直到只剩下一个节点结束

目标是找到新老编号的对应关系，有一个公式，根据新的节点编号，推出删除节点之前的编号信息， 这样就可以直接
返回同一个节点删除之前的编号
(1,1)  最后只剩1个节点，其他节点都被删除之后，编号是1； 那么在2个节点，删除一个节点之前的编号是多少？
(1,1) 只有1个节点，编号为1， 推出-> (2,?) 删除一个节点之前2个节点的编号?  推出 -> (3,?)

a=f(1,2,m)
b=f(a,3,m)
c=f(b,4,m)
...


算法原型： 基础函数y=x%i

节点编号和报数之间的关系： 1->2->3->1
                      1  2  3
                      4  5  6
                      7  8  9

     报数       节点
      1         1
      2         2
      3         3
      4         1
      5         2
      6         3
      7         1
      8         2

   节点 = (报数-1)%i+1;  -->


新老编号的对应关系
老编号： 1 2 3 4 5 6 7 （s节点被杀）
新编号： 5 6 - 1 2 3 4

老编号 = ((新编号-1+s)% i +1;  s是被杀节点的编号

老编号 =  ((新编号+(m-1)%i)%i)+1;        --->  老编号 = ((新编号 + m -1)%i) + 1;



3、


    























