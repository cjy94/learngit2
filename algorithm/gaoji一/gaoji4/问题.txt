1、有序表  SortedMap 实现类 TreeMap
ceilingKey >=  大于等于key的最小值
floorKey <=    小于等于key的最大值

实现有序表的结构： 红黑树、跳表、AVL树， SB树(size-Balance-Tree)
有关有序表的所有操作都是O(logN)

有序表和高度的变化是解决的关键


问题：给定一个N*3的矩阵，对于每一个长度为3的小数组arr，都表示一个大楼的三个数据，arr[0]表示大楼的左边界，arr[1]表示大楼的右边界, arr[2]表示大楼的高度(一定大于0)。
每座大楼的地基都在X轴上，大楼之间可能会重叠，请返回整体的轮廓线数组
matrix= {[2,5,6], [1,7,4], [4,6,7], [3,6,5], [10,13,2], [9,11,3], [12,14,4], [10,12,5]}
返回结果：
result= {[1,2,4], [2,4,6], [4,6,7], [6,7,4], [9,10,3], [10,12,5], [12,14,4]}

关键是关注，一个坐标处高度的变化，
将一个节点的坐标高度值拆解成2个坐标维度信息，左边界高度的增加 和 右边界高度的降低
比如： [2,5,6]  拆解为[2,+,6]:坐标2增加一个高度6     [5,-,6]:坐标5降低一个高度6
      [1,7,4]  拆解为[1,+,4]: 坐标1增加一个高度4    [7,-,4]: 坐标7降低一个高度4
所以： matrix中的坐标全部拆解就是
    [2,+,6]  [5,-,6]
    [1,+,4]  [7,-,4]
    [4,+,7]  [6,-,7]
    [3,+,5]  [6,-,5]
    [10,+,2] [13,-,2]
    [9,+,3]  [11,-,3]
    [12,+,4] [14,-,4]
    [10,+,5] [12,-,5]

  将该信息按照左边界从小到达排序，如果左边界相同，则+排在-前面，不关心第3维的数组, 排序之后的结果
  [1,+,4] [2,+,6] [3,+,5] [4,+,7] [5,-,6]  [6,-,7] [6,-,5] [7,-,4] [9,+,3] [10,+,2] [10,+,5] [11,-,3] [12,+,4]  [12,-,5] [13,-,2] [14,-,4]
  维护两个TreeMap 有序表： heightCountMap(高度次数表，key表示高度，value表示这个高度出现了几次)；xHeightMap(坐标高度表，key表示坐标值，value表示目前高度表中的最大值)
   +: 就将该高度次数+1      -: 就将该高度次数-1, 减为0就删除
  heightCountMap                   xHeightMap
  key    value                    key      value
   4       0(+,-)                  1         4
   6       0(+,-)                  2         6
   5       0(+,-)                  3         6
   7       0(+,-)                  4         7
                                   5         7
                                   6         5
                                   6         4
                                   7         0
   3       0(+,-)                  9         3
   2       0(+,-)                  10        2
   5       0(+,-)                  10        5
                                   11        5
   4       0(+,-)                  12        5
                                   12        4
                                   13        4
                                   14        0



   最后xHeightMap中的key-value是  [1,4] [2,6] [3,6] [4,7] [5,7] [6,4] [7,0] [9,3] [10,5] [11,5] [12,4] [13,4] [14,0]
   xHeightMap中的信息是： key: 坐标值， value: 高度信息，
   所以当高度信息发生变化时，开始记录答案
   答案是： [1,2,4]  [2,4,6] [4,6,7] [6,7,4] [9,10,3] [10,12,5] [12,14,4]


/////////////////////  一系列的子数组问题，{累加和最长数组3联问题}
1、正数数组，构建 [单调性]  , 从某一个起点开始， 一路往下加和的过程中，和一定是递增的，所以当和超过k时， 后面就一定不需要再收集了， 换个开头再求累加和
单调性 + 窗口
2、一个数组中有正数，负数，0 累加和等于k的最长子数组长度
hash表，记录每个前缀和对应的索引位置， 只记录前缀和最早出现的位置


利用hash表，记录两个值key: 某个累加和  value: 当前累加和的索引位置， 记录前缀和最早出现位置
arr[1,2,-1,3,1,1,1] k =3
map              sum=8
key value
 0   -1
 1    0
 2    2
 5    3
 6    4
 7    5

 记录maxLen: 2,
遍历每一个元素， 求累加和sum, 如果map中包含sum-k的value，说明存在sum=k的子数组，获取sum-k出现的索引位置，和sum的索引位置求数组的长度



3、一个数组中有正数，负数，0 累加和<=k的最长子数组长度
arr[]
minSum[] : 从i出发的子数组的所有情况中得到的最小sum
minSumEnd[] : 从i出发最小sum的右边界

arr[] = {-1,3,4,-6,8,5}
minSum[] = {-1,1,-2,-6,8,5}
minSumEnd[] = {0,3,3,3,4,5}


// 数组元素都是正数
 2、 一个arr数组，该数组无序， 但每个值均为整数，在给定一个正数k, 求arr的所有子数组中所有元素相加和为k的最长子数组长度。
 例如： arr[1,2,1,1,1] k=3
 累加和是3的最长子数组为[1,1,1] 结果返回3
 因为数组中的元素都是正数，所以可以构建单调性
 int L, int R sum =0;
 sum < k, r++
 sum > k  l++;
 sum ==k  收集结果，r++



 ////////////////////////////
 给定一个非负数组，每个值代表该位置上有几个铜板，a和b玩游戏，a先手，b后手，轮到某个人的时候，只能再一个位置上拿任意数量的铜板，但不能不拿，谁最先把铜板那完谁赢。
 Nim博弈(尼姆博弈)，如果所有数的异或和==0，那么后手赢； 如果所有数的异或和不等于0，那么先手赢














