1、绳子上覆盖最多的点

2、一种字符放左，一种字符放右的最少方法
 BBGGBBGBG

3、setAll功能的哈希表，put get add操作要求常数时间
4、给定一个正数数组arr，其中每个值代表砖块长度，所有砖块登高等宽，只有长度有区别，每一层可以用1块或者2块砖来摆，要求每一层的长度一样，要求必须使用所有的砖块，请问最多摆几层，如果无法左到返回-1
 1）1 or 2块砖 每一层
 2）每一层长度相同
 3）所有砖块都用
 最多摆几层
将数据分组，每一组数字和相同

将数组排序


5、一开始屏幕上什么也没有，粘贴板里也什么都没有，只能在键盘上做如下4种操作中的一种：
输入：在屏幕上已经显示内容的后面加一个A
全选：把屏幕上已经显示的全部内容选中
复制：被选中的内容复制进粘贴板
粘贴：在屏幕上已经显示内容的后面添加粘贴板里的内容
给定一个正数n, 表示能操作的步数，返回n步内你能让最多多少个A显示在屏幕上


输入、全选、复制、粘贴

当n足够大时，可以直接选择复制粘贴操作


int[] dp = new int[n+1];
for (int i =1; i <=5 && i <= n; i++)
    dp[i] = i;

for (int i =6; i <= n; i++)
    dp[i] = Math.max(
                    Math.max(dp[i-3] * 2, dp[i-4] * 3),
                    Math.max(dp[i-5] * 4, dp[i-6] * 5));


6、苹果放到盘子里的方法数
动态规划

7、给定一个数组arr，可以在每个数字之前决定'+'或者'-'，但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数是多少
  数组中存在正数和负数的情况

  public int process(int[] arr, int index, int rest) {
      if (index == arr.length)
        return rest == 0 ? 1 : 0;

      process(arr, index+1, rest+arr[index]) + process(arr, index+1, rest-arr[index]);
  }

8、司机调度问题    动态规划求解
public int process(int[][] income) {
    int N = income.length;
    int M = N >> 1;
}

9、乘船问题， 正数数组arr，正数limit， 表示所有船共同拥有的载重量，每艘船最多做两人，且不能超过载重，想让所有人同时过河，并且让船尽量少，返回最少的船数

数组排序，找到小于等于limit/2最右的位置L，R第一个超过limit/2的位置

10、返回一个数组中，子数组最大累加和。
    求每一个位置为结尾的最大累加和，在所有位置中取最大值
    
11、字符串交错组成问题
字符串s1和字符串s2，能否交错组成出字符串s3
 s1.length+s2.length == s3.length 才可以


 dp[i][j]含义： 字符串s1[0...i-1]和字符串s2[0...j-1]能否交错组成出字符串s3[0...i+j-1]

1) s1[i-1] == s3[i+j-1]     dp[i-1][j]==true
2) s2[j-1] == s3[i+j-1]     dp[i][j-1]==true
 有一个是true,dp[i][j]就是true


12、求相等子树的数量
以X为头的数，有多少相等的子树

大思路： （左树相等子树的数量 + 右树相等子树的数量）+ 如果左树结构和右树结构相等1 ：否则0
bool f(Node n1, Node n2)   n1为头的树和n2为头的树是否相等
{
if (n1 == null && n2 == null) return true;
if (n1 == null && n2 != null) return false;
if (n1 != null && n2 == null) return false;

return (n1.value == n2.value && f(n1.left, n2.left) && f(n1.right, n2.right));

}

int g(Node x) x为头的树有多少相等的子树
{
 int left = g(x.left);
 int right = g(x.right);
 return (left + right) + f(x.left, x.right) ? 1 : 0;
}

 
O(n*logn)
O(n)

13、编辑距离问题
 保留代价；(d)删除代价；(a)添加代价；(r)替换代价
 



 动态规划求解

14、链表相加
15、递归和master公式
16、二叉树遍历(非递归方式)
先序遍历：(根左右) 先压入头节点，如果有右孩子，压入栈；如果右左孩子，压入栈  进栈顺序(根、右、左)
中序遍历：(左根右) 1、树的整条左边界压入栈； 2、栈弹出打印，重复操作1)； 3、直到没有子树且栈空
后序遍历：(左右根) 1、可以使用先序的方式进栈(根右左), 再利用一个栈逆序即可
 后序遍历有2种方式(2个栈的方式； 1个栈的方式)       h: 代表上次打印的节点
 递归序：任何一个节点经历3次


二进制和位运算
负数表达：0001 --> -1  0000  --> 取反 1111(-1的状态)
         0010 --> -1  0001  --> 取反 1110(-2的状态)


        (-7)1001  --> 0110 --> +1  0111(7)

     整数最小值的特殊性(取绝对值还是自己)

     | 运算符： 有一位是1就是1
     & 运算符： 都是1就是1
     ^ 运算符： 两个位置不相同就是1，相同为0   (无进位相加)

     打印二进制

异或和


位图BitSet
a和b都是非负数，a/b 计算机默认是向下取整的，2/3=0； 想让a/b向上取整转换成 (a+b-1) / b

add(int n)
set[n/32] |= (1 << (n % 32));

remove(int n)
set[n/32] &= ~(1 << (n % 32));

reverse(int n)   改变一个数的状态，如果n在位图中，改为不存在；如果不存在位图中，改为存在
set[n/32] ^= ~(1 << (n % 32));


contains(int n) 位图中是否包含n这个数字
((set[n/32] >> (n%32)) & 1) == 1;



另一种方式的位图
fix(int n): 将i加入到位图
unfix(int n): 将i在位图中删除
flip(): 将所有位翻转

嵌套递归问题


最大公约数、同余原理

gcd(a,b) { return b == 0 ? a : gcd(b, a%b); }

最小公倍数   (a/c) * b   c是最大公约数

同余原理： 神奇数字的增长2,3  

减法
(a-b) % m  --->  (a%m - b%m + m) % m


构建前缀信息
1、构建前缀和数组，快速解决子数组范围求和问题
2、无序数组中，累加和位给定值的子数组数量     子数组一定是连续的


前缀树： 又叫字典树， trie
Trie()   初始化前缀树
insert(String word) 将字符串word插入到前缀树中
search(String word) 返回前缀树中字符串word的实例个数
prefixNumber(String prefix) 返回前缀树中以prefix为前缀的字符串个数
void delete(String word) 从前缀树中移除字符串word     erase       

删除之前要查询是否存在，

线程的优先级：cpu 内核同一时间只能执行一个线程

线程调度器： 分配时间片 ，抢占式任务

没有办法让某个线程肯定能抢到时间片，但是可以提高抢占到的概率，可以设置线程优先级(1 ~ 10) 1优先级最小，10优先级最大
线程的挂起，线程的切换


interrupt(): 线程中断
isInterrupt(): 线程是否中断


线程状态：
NEW:      新建一个线程
RUNNABLE:
BLOCKED:             阻塞状态 (lock())
WAITING:             wait()
TIMED_WAITING:       sleep()
TERMINATED:


线程的生命周期： 

     new Thread()
    新建了一个线程      ----->    线程就绪     ---->    运行      ----->  销毁


join()：线程调用了join方法，那么就要一直运行到该线程运行结束，才会运行其他线程，这样可以控制线程执行顺序
yield(): 当前线程放弃cpu执行权， 让其他线程执行， yeild()只是一个建议，调度器可能会忽略这个建议
A {
    B.join();   //让b线程先执行，
    ---- 等待B线程执行完毕再接着执行
}

有3个线程T1 T2 T3， 如何保证T2再T1之后执行，T3再T2之后执行

    t1 -> t2 -> t3 的顺序执行代码
    
  Thread t1 = new Thread(()->{
    ----- t1自己的逻辑代码
  });

  Thread t2 = new Thread(()->{
    // 先让t1执行
    t1.join();
    ------ t2自己的逻辑代码
  });

  Thread t3 = new Thread(()->{
    // 要让t2先执行
    t2.join();
    ----- t3自己的逻辑代码
  });



  volatile  保证线程的可见性和有序性(禁止指令重排序)， 但是保证不了原子性

  synchronized, 对象监视器机制，monitorenter   monitorexit
  

两个线程交替执行

sleep() 不会释放锁
wait() 会释放锁


线程池：


int corePoolSize,                         核心线程数
int maximumPoolSize,                      最大线程数
long keepAliveTime,                       保持存活时间     最大线程的存活时间
TimeUnit unit,                            时间单位
BlockingQueue<Runnable> workQueue,        任务队列
RejectedExecutionHandler handler          饱和策略

  当池中线程数量 < 核心线程数, 来了新任务就会创建一个线程执行这个任务；
  当池中线程数量 > 核心线程数, 任务队列还没有满, 那么将任务放到队列中；
  当池中线程数量 > 核心线程数, 并且任务队列满了, 也小于最大线程数量, 那么创建新的线程执行这个任务；
  当池中线程数量 > 最大线程数, 并且任务队列满了, 那么执行饱和策略。


线程池的工具类： Executors线程池工具类
newCacheThreadPool() 可缓存的线程池
newFixedThreadPool() 定长线程池
newSingleThreadPool()  单例线程池
newScheduledThreadPool() 调度线程池   1、延迟执行的线程池


java.util.concurrent.Executors                       线程池顶级接口定义了线程池的最基本方法
    java.util.concurrent.ExecutorService             定义常用方法
        java.util.concurrent.ThreadPoolExecutor      线程池的核心实现类



饱和策略：
 CallerRunsPolicy 不抛弃任务，让调用线程池的线程池执行任务
 AbortPolicy  抛弃任务 并抛出异常
 DiscardPolicy  抛弃任务 不抛出异常
 DiscardOldestPolicy  将最早进入队列的任务抛弃，执行最新的任务


 volatile 可见性和有序性

 同步工具：
    CountDownLatch: 允许一条或者多条线程等待其他线程中的一组操作完成后，再继续执行
    Semaphore、
    CyclicBarrier、
    Exchanger
 并发集合：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentSkipSet


 滑动窗口： 维持左、右边界都不回退的一段范围，来求解很多子数组（串）的相关问题
 滑动窗口的关键：找到范围和答案指标之间的单调性关系
 滑动过程：滑动窗口可以用简单变量或者结构来维护信息
 求解大流程： 求子数组在每个位置开头或者结尾情况下的答案
 滑动窗口维持最大值或者最小值的更新结构


 题目：
 1、累加和大于等于target的最短子数组  [3 5 2 6 3 1 3 4 5 6 2 1] target=10   以每一个位置结尾的情况进行讨论
 2、最小覆盖子串问题， 一个字符串s，一个字符串t，返回s中涵盖t所有字符的最小字串。如果s中不存在t所有字符的子串，则返回空字符串""
 3、在一条环路上有n个加油站，其中第i个加油站有汽油gas[i]升， 有一辆油箱容量无限的汽车，从第i个加油站出发，开始时油箱为空，
    给定两个整数数组gas和cost, 如果可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回-1
        通过滑动窗口解决
    
 4、最小改动字符串
 5、k个不同数字的子数组个数， 不同数的种类小于等于k个的子数组个数
   子数组


二分答案法：
1) 估计 最终答案可能的范围 是什么
2) 分析 问题的答案 和 给定条件之间的单调性， 大部分时候只需要用到自然智慧
3) 建立一个f函数，当答案固定的情况下， 判断给定的条件是否达标
4) 在 最终答案可能的范围上不断二分搜索，每次用f函数判断，直到二分结束，找到最合适的答案



01分数规划
给定n个数据，每个数据有(a,b)两个值，并且没有负数
(a1, b1)、(a2, b2)、(a3, b3) ... (an, bn)
其中选出k个数据，希望让： k个a的和 / k个b的和，这个比值尽量大，返回最大的比值



布隆过滤器
存储10个亿的数据状态，可以使用的数据结构，只用120M的内存
1、树结构
2、散列表
3、布隆过滤器(散列表 + BitMap)
判断一个元素是否在集合中，如果不在肯定不在，如果在则有可能在


AVL S-B树 红黑树，都是有序可搜索的二叉树， 大多是在内存中
为什么还要有B树和B+树呢?
二叉搜索树更多时候适用于内存中读取，B树和B+树是多叉树， 更适合磁盘读写，一次读取可以读更多的数据
B+树


B树
B+树


ThreadLocal
ThreadLocalMap, ThreadLocal的静态内部类，并没有在ThreadLocal中使用，而是在Thread中使用
每个Thread对象中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值


单调栈：
每个位置都求
1）当前位置的左侧比当前位置的数字小，且距离最近的位置 在哪
2）当前位置的右侧比当前位置的数字小，且距离最近的位置 在哪
或者
1）当前位置的左侧比当前位置的数字大，且距离最近的位置 在哪
2）当前位置的右侧比当前位置的数字大，且距离最近的位置 在哪

[2,3,4,3,2,1,3,5,6,3,4,3,2]

题目：
1、
2、
3、子数组的最小值之和
    给定一个整数数组arr，找到min(b)的总和，其中b的范围为arr的每个连续子数组。   最后结果可能很大，需要进行取模操作
    比如： [3,1,2,4]
    [3] [1] [2] [4] [3,1] [1,2] [2,4] [3,1,2] [1,2,4] [3,1,2,4]
     3   1   2   4    1     1     2      1       1       1
     3+1+2+4+1+1+2+1+1+1 = 17   和为17
     

4、 直方图中的最大矩形问题

单调栈其他用法
1）单调栈里的所有对象按照 规定好的单调性来组织 
2）当某个对象进入单调栈时， 会从栈顶开始依次淘汰单调栈里对后续求解答案没有帮助的对象
3）每个对象从栈顶弹出时，结算当前对象参与的答案，随后这个对象不再参与后续求解答案的过程
4）其实是先有对题目的分析，进而发现单调性，然后利用单调栈的特征去实现

求一个数组中的最大宽度
去除重复字母保证剩余字符串的字段序最小



统计全是1的子矩阵数量
一个m*n的矩阵，其中只有0和1两种值，返回有多少个子矩阵的元素全部都是1

元素出栈进行结算
二维数组：使用压缩数组技巧




单调队列 和 滑动窗口 有较多联系

窗口问题：
1、绝对差不超过限制的最大连续子数组， 给定一个数组nums，和一个表示限制的整数limit，请返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对值必须小于等于limit
        数组先进行排序 



maxDeque
minDeque
maxh maxt minh mint

花盆接水问题：窗口变化[L,R]  


滑动窗口维持窗口内的最大值和最小值

















 





























 


 