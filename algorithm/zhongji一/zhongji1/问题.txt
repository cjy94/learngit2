1、 给定一个有序数组arr，代表数轴上从左到右有n个点arr[0]、arr[1]...arr[n-1]， 给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点

没必要把绳子的末端（右侧端点）放在一个不存在的点上
在某一个区域，找大于等于某一个数最左的位置， O(N logN)


窗口问题： 滑动窗口最大值和最小值的处理流程
更优的算法： 滑动窗口， 绳子左侧边界来到一个点，
单调不递减


2、小虎去附近的商店买苹果，只提供6个每袋和8个每袋的包装不可拆。 可是小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋子。
如果不能恰好n个苹果，将不能购买， 输入一个整数n，表示小虎想购买
的苹果， 返回最小使用多少袋子。如果无论如何都不能装下，返回-1。

如果n=100
 8个袋子   6个袋子
  12        -1
  11         2 (13)
  10        -1
  9         -1
  8          6 (14)
  7         -1
  6         -1
  5         10 (15)
  4         -1
  3         -1
  2         14 (16)
  1         -1
  0         -1

3、先手和后手吃草问题，1、4、16、64... 问题

0份草： 后手赢， 因为先手最先没得吃
1份草： 先手赢
2份草： 后手赢
3份草： 先手赢
4份草： 先手赢

4、染色问题： RGRGRG， 想要的效果是： G(左侧) R(右侧)
 
尝试左侧0个、1个、2个、3个G...的情况， 需要染几个颜色

不优化O(N^2) 可以预先处理数组，
创建2个辅助数组
[] 0..i 位置有几个G
[] i..n-1 位置有几个R

for (int L =0; L <= N; L++) {
     if (L==0) {
        检查一共有多少个G
     } else if(L == N) {
        检查一共有多少个R
     } else {
        // [0...L] 和 [L+1...N] 范围
        检查[0..L] 有多少R
        [L+1...N] 有多少G
    
     }
}

5、
