1、城市和首都的距离问题
给定一个路径数组paths，表示一张图，paths[i]=j， 代表城市i连向城市j，如果paths[i]=i， 表示i城市是首都，一张图里只会有一个首都且图中除首都都指向自己之外不会有环
例如， paths=[9, 1, 4, 9, 0, 4, 8, 9, 0, 1]
             0  1  2  3  4  5  6  7  8  9

             形成的图结构是：
                  1 (首都)
                 /
                9
             /  \  \
            0   3   7
           / \
          8   4
         /   / \
        6    2  5

 最终的数组应该是 [1 1 3 2 3 0 0 0 0 0]
                0 1 2 3 4 5 6 7 8 9

   数组中的含义：   1城市是首都，arr[0]表示距离首都是0的城市有1座， arr[1]距离首都是1的城市有1座， arr[2]距离首都是2的城市有3座
                            arr[3]距离首都是3的城市有2座， arr[4]距离首都是4的城市有3座， arr[5]距离首都是5的城市有0座...

不使用额外的空间，in-place计算, 在原数组中计算较难

(1.1) graphToDistanceArray()  城市首都的距离数组
  [9, 1, 4, 9, 0, 4, 8, 9, 0, 1]
  []



2、小朋友分糖果问题
一群孩子做游戏，现在请你根据游戏得分来法糖果，
要求如下： 1、每个孩子不管得分多少，起码分到1个糖果；2、任意两个相邻的孩子之间，得分较多的孩子必须多拿一些糖果，给定一个数组arr代表得分数组，请返回最少需要多少糖果，
例如arr[1, 2 ,2]  糖果分配为(1,2,1)即可满足， 返回4



利用坡度进行分糖， left < cur  糖果+1； left >= cur 糖果变成1  (当前值大于左侧/右侧的值，糖果+1, 否则糖果变成1)
arr=  [4 3 3 2 2 4 5 5 4 3 3 2 1 4 4]
left= [1 1 1 1 1 2 3 1 1 1 1 1 1 2 1]
right=[2 1 2 1 1 1 1 3 2 1 3 2 1 1 1]
left[i]和right[i]数组取最大值
res=  [2 1 2 1 1 2 3 3 2 1 3 2 1 2 1]


进阶：添加一个规则，3、任意两个相邻孩子之间如果得分一样，糖果数必须相同
例如arr[1, 2, 2]  糖果分配为(1,2,2)即可满足， 返回5

利用坡度进行分糖， left < cur  糖果+1； left > cur 糖果变成1； left = cur  糖果维持不变
arr=  [4 3 3 2 2 4 5 5 4 3 3 2 1 4 4]
left= [1 1 1 1 1 2 3 3 1 1 1 1 1 2 2]
right=[3 2 2 1 1 1 5 5 4 3 3 2 1 1 1]
res=  [3 2 2 1 1 2 5 5 4 3 3 2 1 2 2]

空间复杂度O(N)的情况，比较简单，如果空间复杂度O(1)的较难







3、节点放相机问题 （二叉树的递归套路问题）
给定一棵二叉树，头节点head, 如果某一个节点x上放置相机，那么x的父节点、x的所有子节点以及x都可以被覆盖，返回如果
要把所有数都覆盖，至少需要多少个相机?
情况有3种：  所有情况都要保证x下方的所有节点都被覆盖住
3.1 x节点放相机，x下面的节点都被覆盖
3.2 x节点不放相机, 但是x节点能被覆盖， x下面的节点都被覆盖
3.3 x节点不放相机, x节点没有被覆盖， 但是x下面的节点都被覆盖了


